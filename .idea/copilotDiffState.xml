<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/moe/fuqiuluo/portal/ui/viewmodel/MockServiceViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/moe/fuqiuluo/portal/ui/viewmodel/MockServiceViewModel.kt" />
              <option name="originalContent" value="package moe.fuqiuluo.portal.ui.viewmodel&#10;&#10;import android.app.Activity&#10;import android.location.LocationManager&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import com.tencent.bugly.crashreport.CrashReport&#10;import kotlinx.coroutines.GlobalScope&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import moe.fuqiuluo.portal.android.coro.CoroutineController&#10;import moe.fuqiuluo.portal.android.coro.CoroutineRouteMock&#10;import moe.fuqiuluo.portal.ext.Loc4j&#10;import moe.fuqiuluo.portal.ext.accuracy&#10;import moe.fuqiuluo.portal.ext.altitude&#10;import moe.fuqiuluo.portal.ext.reportDuration&#10;import moe.fuqiuluo.portal.ext.speed&#10;import moe.fuqiuluo.portal.service.MockServiceHelper&#10;import moe.fuqiuluo.portal.ui.mock.HistoricalLocation&#10;import moe.fuqiuluo.portal.ui.mock.HistoricalRoute&#10;import moe.fuqiuluo.portal.ui.mock.Rocker&#10;import moe.fuqiuluo.xposed.utils.FakeLoc&#10;import net.sf.geographiclib.Geodesic&#10;&#10;class MockServiceViewModel : ViewModel() {&#10;    lateinit var rocker: Rocker&#10;    private lateinit var rockerJob: Job&#10;    private lateinit var routeMockJob: Job&#10;    var isRockerLocked = false&#10;    var routeStage = 0&#10;    val rockerCoroutineController = CoroutineController()&#10;    val routeMockCoroutine = CoroutineRouteMock()&#10;&#10;    var isRouteStart = false&#10;&#10;    var locationManager: LocationManager? = null&#10;        set(value) {&#10;            field = value&#10;            if (value != null)&#10;                MockServiceHelper.tryInitService(value)&#10;        }&#10;&#10;    var selectedLocation: HistoricalLocation? = null&#10;    var selectedRoute: HistoricalRoute? = null&#10;&#10;&#10;    fun initRocker(activity: Activity): Rocker {&#10;        if (!::rocker.isInitialized) {&#10;            rocker = Rocker(activity)&#10;        }&#10;&#10;        if (!::rockerJob.isInitialized || rockerJob.isCancelled) {&#10;            rockerCoroutineController.pause()&#10;            val delayTime = activity.reportDuration.toLong()&#10;            val applicationContext = activity.applicationContext&#10;            rockerJob = GlobalScope.launch {&#10;                do {&#10;                    rockerCoroutineController.controlledCoroutine()&#10;                    delay(delayTime)&#10;&#10;                    CrashReport.setUserSceneTag(applicationContext, 261773)&#10;                    if(!MockServiceHelper.move(locationManager!!, FakeLoc.speed / (1000 / delayTime) / 0.85, FakeLoc.bearing)) {&#10;                        Log.e(&quot;MockServiceViewModel&quot;, &quot;Failed to move&quot;)&#10;                    }&#10;&#10;//                    if (MockServiceHelper.broadcastLocation(locationManager!!)) {&#10;//                        Log.d(&quot;MockServiceViewModel&quot;, &quot;Broadcast location&quot;)&#10;//                    } else {&#10;//                        Log.e(&quot;MockServiceViewModel&quot;, &quot;Failed to broadcast location&quot;)&#10;//                    }&#10;                } while (isActive)&#10;            }&#10;        }&#10;&#10;        FakeLoc.speed = activity.speed&#10;        FakeLoc.altitude = activity.altitude&#10;        FakeLoc.accuracy = activity.accuracy&#10;&#10;        if (!::routeMockJob.isInitialized || routeMockJob.isCancelled) {&#10;            routeMockCoroutine.pause()&#10;            val delayTime = activity.reportDuration.toLong()&#10;            routeMockJob = GlobalScope.launch {&#10;                do {&#10;                    routeMockCoroutine.routeMockCoroutine()&#10;                    delay(delayTime)&#10;                    // 如果是第0阶段，定位到第一个点&#10;                    if (routeStage == 0) {&#10;                        MockServiceHelper.setLocation(&#10;                            locationManager!!,&#10;                            selectedRoute!!.route[0].first,&#10;                            selectedRoute!!.route[0].second&#10;                        )&#10;                        routeStage++&#10;                    }&#10;                    val route = selectedRoute!!.route&#10;&#10;                    // 处理所有已到达的阶段&#10;                    while (routeStage &lt; route.size) {&#10;                        val target = route[routeStage]&#10;                        val location = MockServiceHelper.getLocation(locationManager!!)&#10;                        val currentLat = location!!.first&#10;                        val currentLon = location.second&#10;&#10;                        val inverse = Geodesic.WGS84.Inverse(&#10;                            currentLat,&#10;                            currentLon,&#10;                            target.first,&#10;                            target.second&#10;                        )&#10;                        // 判断距离是否小于1米（可根据需要调整阈值）&#10;                        if (inverse.s12 &lt; 1.0) {&#10;                            // 精确设置位置到目标点并进入下一阶段&#10;                            MockServiceHelper.setLocation(&#10;                                locationManager!!,&#10;                                target.first,&#10;                                target.second&#10;                            )&#10;                            routeStage++&#10;                        } else if (inverse.s12 &lt; FakeLoc.speed / (1000 / delayTime) / 0.85) {&#10;                            // 如果距离小于速度，直接移动到目标点&#10;                            MockServiceHelper.setLocation(&#10;                                locationManager!!,&#10;                                target.first,&#10;                                target.second&#10;                            )&#10;                            routeStage++&#10;&#10;                        } else {&#10;                            break&#10;                        }&#10;                    }&#10;&#10;                    // 检查是否已完成所有阶段&#10;                    if (routeStage &gt;= route.size) {&#10;                        routeMockCoroutine.pause()&#10;                        rocker.autoStatus = false&#10;                        // 重设阶段&#10;                        routeStage = 0&#10;                        break // 退出循环&#10;                    }&#10;&#10;                    // 处理当前目标点的移动&#10;                    val target = route[routeStage]&#10;                    val location = MockServiceHelper.getLocation(locationManager!!)&#10;                    val currentLat = location!!.first&#10;                    val currentLon = location.second&#10;&#10;                    val inverse = Geodesic.WGS84.Inverse(&#10;                        currentLat,&#10;                        currentLon,&#10;                        target.first,&#10;                        target.second&#10;                    )&#10;                    var azimuth = inverse.azi1&#10;                    if (azimuth &lt; 0) {&#10;                        azimuth += 360&#10;                    }&#10;&#10;                    Log.d(&quot;MockServiceViewModel&quot;, &quot;从 $currentLat, $currentLon 移动到 ${target.first}, ${target.second}, 方位角: $azimuth&quot;)&#10;                    if (!MockServiceHelper.move(&#10;                            locationManager!!,&#10;                            FakeLoc.speed / (1000 / delayTime) / 0.85,&#10;                            azimuth&#10;                        )&#10;                    ) {&#10;                        Log.e(&quot;MockServiceViewModel&quot;, &quot;移动失败&quot;)&#10;                    }&#10;                } while (isActive)&#10;            }&#10;        }&#10;&#10;        return rocker&#10;    }&#10;&#10;    fun isServiceStart(): Boolean {&#10;        return locationManager != null &amp;&amp; MockServiceHelper.isServiceInit() &amp;&amp; MockServiceHelper.isMockStart(&#10;            locationManager!!&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package moe.fuqiuluo.portal.ui.viewmodel&#13;&#10;&#13;&#10;import android.app.Activity&#13;&#10;import android.location.LocationManager&#13;&#10;import android.util.Log&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import com.tencent.bugly.crashreport.CrashReport&#13;&#10;import kotlinx.coroutines.GlobalScope&#13;&#10;import kotlinx.coroutines.Job&#13;&#10;import kotlinx.coroutines.delay&#13;&#10;import kotlinx.coroutines.isActive&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import moe.fuqiuluo.portal.android.coro.CoroutineController&#13;&#10;import moe.fuqiuluo.portal.android.coro.CoroutineRouteMock&#13;&#10;import moe.fuqiuluo.portal.ext.Loc4j&#13;&#10;import moe.fuqiuluo.portal.ext.accuracy&#13;&#10;import moe.fuqiuluo.portal.ext.altitude&#13;&#10;import moe.fuqiuluo.portal.ext.reportDuration&#13;&#10;import moe.fuqiuluo.portal.ext.speed&#13;&#10;import moe.fuqiuluo.portal.service.MockServiceHelper&#13;&#10;import moe.fuqiuluo.portal.ui.mock.HistoricalLocation&#13;&#10;import moe.fuqiuluo.portal.ui.mock.HistoricalRoute&#13;&#10;import moe.fuqiuluo.portal.ui.mock.Rocker&#13;&#10;import moe.fuqiuluo.xposed.utils.FakeLoc&#13;&#10;import net.sf.geographiclib.Geodesic&#13;&#10;&#13;&#10;class MockServiceViewModel : ViewModel() {&#13;&#10;    lateinit var rocker: Rocker&#13;&#10;    private lateinit var rockerJob: Job&#13;&#10;    private lateinit var routeMockJob: Job&#13;&#10;    var isRockerLocked = false&#13;&#10;    var routeStage = 0&#13;&#10;    val rockerCoroutineController = CoroutineController()&#13;&#10;    val routeMockCoroutine = CoroutineRouteMock()&#13;&#10;&#13;&#10;    var isRouteStart = false&#13;&#10;&#13;&#10;    var locationManager: LocationManager? = null&#13;&#10;        set(value) {&#13;&#10;            field = value&#13;&#10;            if (value != null)&#13;&#10;                MockServiceHelper.tryInitService(value)&#13;&#10;        }&#13;&#10;&#13;&#10;    var selectedLocation: HistoricalLocation? = null&#13;&#10;    var selectedRoute: HistoricalRoute? = null&#13;&#10;&#13;&#10;&#13;&#10;    fun initRocker(activity: Activity): Rocker {&#13;&#10;        if (!::rocker.isInitialized) {&#13;&#10;            rocker = Rocker(activity)&#13;&#10;        }&#13;&#10;&#13;&#10;        if (!::rockerJob.isInitialized || rockerJob.isCancelled) {&#13;&#10;            rockerCoroutineController.pause()&#13;&#10;            val delayTime = activity.reportDuration.toLong()&#13;&#10;            val applicationContext = activity.applicationContext&#13;&#10;            rockerJob = GlobalScope.launch {&#13;&#10;                do {&#13;&#10;                    rockerCoroutineController.controlledCoroutine()&#13;&#10;                    delay(delayTime)&#13;&#10;&#13;&#10;                    CrashReport.setUserSceneTag(applicationContext, 261773)&#13;&#10;                    if(!MockServiceHelper.move(locationManager!!, FakeLoc.speed / (1000 / delayTime) / 0.85, FakeLoc.bearing)) {&#13;&#10;                        Log.e(&quot;MockServiceViewModel&quot;, &quot;Failed to move&quot;)&#13;&#10;                    }&#13;&#10;&#13;&#10;//                    if (MockServiceHelper.broadcastLocation(locationManager!!)) {&#13;&#10;//                        Log.d(&quot;MockServiceViewModel&quot;, &quot;Broadcast location&quot;)&#13;&#10;//                    } else {&#13;&#10;//                        Log.e(&quot;MockServiceViewModel&quot;, &quot;Failed to broadcast location&quot;)&#13;&#10;//                    }&#13;&#10;                } while (isActive)&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        FakeLoc.speed = activity.speed&#13;&#10;        FakeLoc.altitude = activity.altitude&#13;&#10;        FakeLoc.accuracy = activity.accuracy&#13;&#10;&#13;&#10;        if (!::routeMockJob.isInitialized || routeMockJob.isCancelled) {&#13;&#10;            routeMockCoroutine.pause()&#13;&#10;            val delayTime = activity.reportDuration.toLong()&#13;&#10;            routeMockJob = GlobalScope.launch {&#13;&#10;                do {&#13;&#10;                    routeMockCoroutine.routeMockCoroutine()&#13;&#10;                    delay(delayTime)&#13;&#10;                    // 如果是第0阶段，定位到第一个点&#13;&#10;                    if (routeStage == 0) {&#13;&#10;                        MockServiceHelper.setLocation(&#13;&#10;                            locationManager!!,&#13;&#10;                            selectedRoute!!.route[0].first,&#13;&#10;                            selectedRoute!!.route[0].second&#13;&#10;                        )&#13;&#10;                        routeStage++&#13;&#10;                    }&#13;&#10;                    val route = selectedRoute!!.route&#13;&#10;&#13;&#10;                    // 处理所有已到达的阶段&#13;&#10;                    while (routeStage &lt; route.size) {&#13;&#10;                        val target = route[routeStage]&#13;&#10;                        val location = MockServiceHelper.getLocation(locationManager!!)&#13;&#10;                        val currentLat = location!!.first&#13;&#10;                        val currentLon = location.second&#13;&#10;&#13;&#10;                        val inverse = Geodesic.WGS84.Inverse(&#13;&#10;                            currentLat,&#13;&#10;                            currentLon,&#13;&#10;                            target.first,&#13;&#10;                            target.second&#13;&#10;                        )&#13;&#10;                        // 判断距离是否小于1米（可根据需要调整阈值）&#13;&#10;                        if (inverse.s12 &lt; 1.0) {&#13;&#10;                            // 精确设置位置到目标点并进入下一阶段&#13;&#10;                            MockServiceHelper.setLocation(&#13;&#10;                                locationManager!!,&#13;&#10;                                target.first,&#13;&#10;                                target.second&#13;&#10;                            )&#13;&#10;                            routeStage++&#13;&#10;                        } else if (inverse.s12 &lt; FakeLoc.speed / (1000 / delayTime) / 0.85) {&#13;&#10;                            // 如果距离小于速度，直接移动到目标点&#13;&#10;                            MockServiceHelper.setLocation(&#13;&#10;                                locationManager!!,&#13;&#10;                                target.first,&#13;&#10;                                target.second&#13;&#10;                            )&#13;&#10;                            routeStage++&#13;&#10;&#13;&#10;                        } else {&#13;&#10;                            break&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // 检查是否已完成所有阶段&#13;&#10;                    if (routeStage &gt;= route.size) {&#13;&#10;                        routeMockCoroutine.pause()&#13;&#10;                        rocker.autoStatus = false&#13;&#10;                        // 重设阶段&#13;&#10;                        routeStage = 0&#13;&#10;                        break // 退出循环&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // 处理当前目标点的移动&#13;&#10;                    val target = route[routeStage]&#13;&#10;                    val location = MockServiceHelper.getLocation(locationManager!!)&#13;&#10;                    val currentLat = location!!.first&#13;&#10;                    val currentLon = location.second&#13;&#10;&#13;&#10;                    val inverse = Geodesic.WGS84.Inverse(&#13;&#10;                        currentLat,&#13;&#10;                        currentLon,&#13;&#10;                        target.first,&#13;&#10;                        target.second&#13;&#10;                    )&#13;&#10;                    var azimuth = inverse.azi1&#13;&#10;                    if (azimuth &lt; 0) {&#13;&#10;                        azimuth += 360&#13;&#10;                    }&#13;&#10;&#13;&#10;                    Log.d(&quot;MockServiceViewModel&quot;, &quot;从 $currentLat, $currentLon 移动到 ${target.first}, ${target.second}, 方位角: $azimuth&quot;)&#13;&#10;                    if (!MockServiceHelper.move(&#13;&#10;                            locationManager!!,&#13;&#10;                            FakeLoc.speed / (1000 / delayTime) / 0.85,&#13;&#10;                            azimuth&#13;&#10;                        )&#13;&#10;                    ) {&#13;&#10;                        Log.e(&quot;MockServiceViewModel&quot;, &quot;移动失败&quot;)&#13;&#10;                    }&#13;&#10;                } while (isActive)&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        return rocker&#13;&#10;    }&#13;&#10;&#13;&#10;    fun isServiceStart(): Boolean {&#13;&#10;        return locationManager != null &amp;&amp; MockServiceHelper.isServiceInit() &amp;&amp; MockServiceHelper.isMockStart(&#13;&#10;            locationManager!!&#13;&#10;        )&#13;&#10;    }&#13;&#10;&#13;&#10;    // WiFi Hook相关属性&#13;&#10;    var isWifiHookEnabled: Boolean = true&#13;&#10;        set(value) {&#13;&#10;            field = value&#13;&#10;            // 这里可以通过某种方式通知Xposed模块更新配置&#13;&#10;            Log.i(&quot;MockServiceViewModel&quot;, &quot;WiFi Hook已${if (value) &quot;启用&quot; else &quot;禁用&quot;}&quot;)&#13;&#10;        }&#13;&#10;    &#13;&#10;    var isWifiDetailLogEnabled: Boolean = false&#13;&#10;        set(value) {&#13;&#10;            field = value&#13;&#10;            Log.i(&quot;MockServiceViewModel&quot;, &quot;WiFi详细日志已${if (value) &quot;启用&quot; else &quot;禁用&quot;}&quot;)&#13;&#10;        }&#13;&#10;&#13;&#10;    // WiFi Hook白名单应用&#13;&#10;    private val wifiHookWhitelist = mutableSetOf&lt;String&gt;()&#13;&#10;    &#13;&#10;    // WiFi Hook黑名单应用（强制拦截）&#13;&#10;    private val wifiHookBlacklist = mutableSetOf(&#13;&#10;        &quot;com.baidu.BaiduMap&quot;,&#13;&#10;        &quot;com.autonavi.minimap&quot;,&#13;&#10;        &quot;com.tencent.map&quot;,&#13;&#10;        &quot;com.google.android.apps.maps&quot;&#13;&#10;    )&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * 添加应用到WiFi Hook白名单&#13;&#10;     */&#13;&#10;    fun addToWifiWhitelist(packageName: String) {&#13;&#10;        wifiHookWhitelist.add(packageName)&#13;&#10;        Log.i(&quot;MockServiceViewModel&quot;, &quot;已将 $packageName 添加到WiFi Hook白名单&quot;)&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * 从WiFi Hook白名单移除应用&#13;&#10;     */&#13;&#10;    fun removeFromWifiWhitelist(packageName: String) {&#13;&#10;        wifiHookWhitelist.remove(packageName)&#13;&#10;        Log.i(&quot;MockServiceViewModel&quot;, &quot;已将 $packageName 从WiFi Hook白名单移除&quot;)&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * 添加应用到WiFi Hook黑名单&#13;&#10;     */&#13;&#10;    fun addToWifiBlacklist(packageName: String) {&#13;&#10;        wifiHookBlacklist.add(packageName)&#13;&#10;        Log.i(&quot;MockServiceViewModel&quot;, &quot;已将 $packageName 添加到WiFi Hook黑名单&quot;)&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * 从WiFi Hook黑名单移除应用&#13;&#10;     */&#13;&#10;    fun removeFromWifiBlacklist(packageName: String) {&#13;&#10;        wifiHookBlacklist.remove(packageName)&#13;&#10;        Log.i(&quot;MockServiceViewModel&quot;, &quot;已将 $packageName 从WiFi Hook黑名单移除&quot;)&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * 获取WiFi Hook白名单&#13;&#10;     */&#13;&#10;    fun getWifiWhitelist(): Set&lt;String&gt; = wifiHookWhitelist.toSet()&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * 获取WiFi Hook黑名单&#13;&#10;     */&#13;&#10;    fun getWifiBlacklist(): Set&lt;String&gt; = wifiHookBlacklist.toSet()&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * 重置WiFi Hook配置&#13;&#10;     */&#13;&#10;    fun resetWifiHookConfig() {&#13;&#10;        wifiHookWhitelist.clear()&#13;&#10;        wifiHookBlacklist.clear()&#13;&#10;        wifiHookBlacklist.addAll(setOf(&#13;&#10;            &quot;com.baidu.BaiduMap&quot;,&#13;&#10;            &quot;com.autonavi.minimap&quot;,&#13;&#10;            &quot;com.tencent.map&quot;,&#13;&#10;            &quot;com.google.android.apps.maps&quot;&#13;&#10;        ))&#13;&#10;        isWifiHookEnabled = true&#13;&#10;        isWifiDetailLogEnabled = false&#13;&#10;        Log.i(&quot;MockServiceViewModel&quot;, &quot;WiFi Hook配置已重置&quot;)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/xposed/src/main/java/moe/fuqiuluo/xposed/FakeLocation.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/xposed/src/main/java/moe/fuqiuluo/xposed/FakeLocation.kt" />
              <option name="originalContent" value="@file:Suppress(&quot;LocalVariableName&quot;, &quot;PrivateApi&quot;, &quot;UNCHECKED_CAST&quot;)&#10;package moe.fuqiuluo.xposed&#10;&#10;import de.robv.android.xposed.IXposedHookLoadPackage&#10;import de.robv.android.xposed.IXposedHookZygoteInit&#10;import de.robv.android.xposed.XposedHelpers&#10;import de.robv.android.xposed.callbacks.XC_LoadPackage&#10;import moe.fuqiuluo.xposed.hooks.LocationManagerHook&#10;import moe.fuqiuluo.xposed.hooks.LocationServiceHook&#10;import moe.fuqiuluo.xposed.hooks.fused.AndroidFusedLocationProviderHook&#10;import moe.fuqiuluo.xposed.hooks.fused.ThirdPartyLocationHook&#10;import moe.fuqiuluo.xposed.hooks.oplus.OplusLocationHook&#10;import moe.fuqiuluo.xposed.hooks.telephony.miui.MiuiTelephonyManagerHook&#10;import moe.fuqiuluo.xposed.hooks.sensor.SystemSensorManagerHook&#10;import moe.fuqiuluo.xposed.hooks.telephony.TelephonyHook&#10;import moe.fuqiuluo.xposed.hooks.wlan.WlanHook&#10;import moe.fuqiuluo.xposed.utils.FakeLoc&#10;import moe.fuqiuluo.xposed.utils.Logger&#10;&#10;class FakeLocation: IXposedHookLoadPackage, IXposedHookZygoteInit {&#10;    private lateinit var cServiceManager: Class&lt;*&gt; // android.os.ServiceManager&#10;    private val mServiceManagerCache by lazy {&#10;        kotlin.runCatching { cServiceManager.getDeclaredField(&quot;sCache&quot;) }.onSuccess {&#10;            it.isAccessible = true&#10;        }.getOrNull()&#10;        // the field is not guaranteed to exist&#10;    }&#10;&#10;    /**&#10;     * Called very early during startup of Zygote.&#10;     * @param startupParam Details about the module itself and the started process.&#10;     * @throws Throwable everything is caught, but will prevent further initialization of the module.&#10;     */&#10;    override fun initZygote(startupParam: IXposedHookZygoteInit.StartupParam?) {&#10;        if(startupParam == null) return&#10;&#10;//        // 宇宙安全声明：以下代码仅供学习交流使用，切勿用于非法用途?&#10;//        System.setProperty(&quot;portal.enable&quot;, &quot;true&quot;)&#10;    }&#10;&#10;    /**&#10;     * This method is called when an app is loaded. It's called very early, even before&#10;     * [Application.onCreate] is called.&#10;     * Modules can set up their app-specific hooks here.&#10;     *&#10;     * @param lpparam Information about the app.&#10;     * @throws Throwable Everything the callback throws is caught and logged.&#10;     */&#10;    override fun handleLoadPackage(lpparam: XC_LoadPackage.LoadPackageParam?) {&#10;        if (lpparam?.packageName != &quot;android&quot; &amp;&amp; lpparam?.packageName != &quot;com.android.phone&quot;) {&#10;            return&#10;        }&#10;&#10;        val systemClassLoader = (kotlin.runCatching {&#10;            lpparam.classLoader.loadClass(&quot;android.app.ActivityThread&quot;)&#10;                ?: Class.forName(&quot;android.app.ActivityThread&quot;)&#10;        }.onFailure {&#10;            Logger.error(&quot;Failed to find ActivityThread&quot;, it)&#10;        }.getOrNull() ?: return)&#10;            .getMethod(&quot;currentActivityThread&quot;)&#10;            .invoke(null)&#10;            .javaClass&#10;            .getClassLoader()&#10;&#10;        if (systemClassLoader == null) {&#10;            Logger.error(&quot;Failed to get system class loader&quot;)&#10;            return&#10;        }&#10;&#10;        if(System.getProperty(&quot;portal.injected_${lpparam.packageName}&quot;) == &quot;true&quot;) {&#10;            return&#10;        } else {&#10;            System.setProperty(&quot;portal.injected_${lpparam.packageName}&quot;, &quot;true&quot;)&#10;        }&#10;&#10;        when (lpparam.packageName) {&#10;            &quot;com.android.phone&quot; -&gt; {&#10;                Logger.info(&quot;Found com.android.phone&quot;)&#10;                TelephonyHook(lpparam.classLoader)&#10;                MiuiTelephonyManagerHook(lpparam.classLoader)&#10;            }&#10;            &quot;android&quot; -&gt; {&#10;                Logger.info(&quot;Debug Log Status: ${FakeLoc.enableDebugLog}&quot;)&#10;                FakeLoc.isSystemServerProcess = true&#10;                startFakeLocHook(systemClassLoader)&#10;                TelephonyHook.hookSubOnTransact(lpparam.classLoader)&#10;                WlanHook(systemClassLoader)&#10;                AndroidFusedLocationProviderHook(lpparam.classLoader)&#10;                SystemSensorManagerHook(lpparam.classLoader)&#10;&#10;                ThirdPartyLocationHook(lpparam.classLoader)&#10;            }&#10;            &quot;com.android.location.fused&quot; -&gt; {&#10;                AndroidFusedLocationProviderHook(lpparam.classLoader)&#10;            }&#10;            &quot;com.xiaomi.location.fused&quot; -&gt; {&#10;                ThirdPartyLocationHook(lpparam.classLoader)&#10;            }&#10;            &quot;com.oplus.location&quot; -&gt; {&#10;                OplusLocationHook(lpparam.classLoader)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startFakeLocHook(classLoader: ClassLoader) {&#10;        cServiceManager = XposedHelpers.findClass(&quot;android.os.ServiceManager&quot;, classLoader)&#10;&#10;        XposedHelpers.findClassIfExists(&quot;com.android.server.TelephonyRegistry&quot;, classLoader)?.let {&#10;            TelephonyHook.hookTelephonyRegistry(it)&#10;        } // for MUMU emulator&#10;&#10;        val cLocationManager =&#10;            XposedHelpers.findClass(&quot;android.location.LocationManager&quot;, classLoader)&#10;&#10;        LocationServiceHook(classLoader)&#10;        LocationManagerHook(cLocationManager)  // intrusive hooks&#10;    }&#10;}" />
              <option name="updatedContent" value="@file:Suppress(&quot;LocalVariableName&quot;, &quot;PrivateApi&quot;, &quot;UNCHECKED_CAST&quot;)&#13;&#10;package moe.fuqiuluo.xposed&#13;&#10;&#13;&#10;import de.robv.android.xposed.IXposedHookLoadPackage&#13;&#10;import de.robv.android.xposed.IXposedHookZygoteInit&#13;&#10;import de.robv.android.xposed.XposedHelpers&#13;&#10;import de.robv.android.xposed.callbacks.XC_LoadPackage&#13;&#10;import moe.fuqiuluo.xposed.hooks.LocationManagerHook&#13;&#10;import moe.fuqiuluo.xposed.hooks.LocationServiceHook&#13;&#10;import moe.fuqiuluo.xposed.hooks.fused.AndroidFusedLocationProviderHook&#13;&#10;import moe.fuqiuluo.xposed.hooks.fused.ThirdPartyLocationHook&#13;&#10;import moe.fuqiuluo.xposed.hooks.oplus.OplusLocationHook&#13;&#10;import moe.fuqiuluo.xposed.hooks.telephony.miui.MiuiTelephonyManagerHook&#13;&#10;import moe.fuqiuluo.xposed.hooks.sensor.SystemSensorManagerHook&#13;&#10;import moe.fuqiuluo.xposed.hooks.telephony.TelephonyHook&#13;&#10;import moe.fuqiuluo.xposed.hooks.wlan.WlanHook&#13;&#10;import moe.fuqiuluo.xposed.hooks.wlan.MapAppWifiHook&#13;&#10;import moe.fuqiuluo.xposed.utils.FakeLoc&#13;&#10;import moe.fuqiuluo.xposed.utils.Logger&#13;&#10;&#13;&#10;class FakeLocation: IXposedHookLoadPackage, IXposedHookZygoteInit {&#13;&#10;    private lateinit var cServiceManager: Class&lt;*&gt; // android.os.ServiceManager&#13;&#10;    private val mServiceManagerCache by lazy {&#13;&#10;        kotlin.runCatching { cServiceManager.getDeclaredField(&quot;sCache&quot;) }.onSuccess {&#13;&#10;            it.isAccessible = true&#13;&#10;        }.getOrNull()&#13;&#10;        // the field is not guaranteed to exist&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Called very early during startup of Zygote.&#13;&#10;     * @param startupParam Details about the module itself and the started process.&#13;&#10;     * @throws Throwable everything is caught, but will prevent further initialization of the module.&#13;&#10;     */&#13;&#10;    override fun initZygote(startupParam: IXposedHookZygoteInit.StartupParam?) {&#13;&#10;        if(startupParam == null) return&#13;&#10;&#13;&#10;//        // 宇宙安全声明：以下代码仅供学习交流使用，切勿用于非法用途?&#13;&#10;//        System.setProperty(&quot;portal.enable&quot;, &quot;true&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * This method is called when an app is loaded. It's called very early, even before&#13;&#10;     * [Application.onCreate] is called.&#13;&#10;     * Modules can set up their app-specific hooks here.&#13;&#10;     *&#13;&#10;     * @param lpparam Information about the app.&#13;&#10;     * @throws Throwable Everything the callback throws is caught and logged.&#13;&#10;     */&#13;&#10;    override fun handleLoadPackage(lpparam: XC_LoadPackage.LoadPackageParam?) {&#13;&#10;        // 首先处理地图类应用的WiFi Hook&#13;&#10;        if (lpparam?.packageName != null &amp;&amp; lpparam.packageName != &quot;android&quot; &amp;&amp; lpparam.packageName != &quot;com.android.phone&quot;) {&#13;&#10;            // Hook地图类应用的WiFi功能&#13;&#10;            MapAppWifiHook(lpparam.classLoader, lpparam.packageName)&#13;&#10;        }&#13;&#10;        &#13;&#10;        if (lpparam?.packageName != &quot;android&quot; &amp;&amp; lpparam?.packageName != &quot;com.android.phone&quot;) {&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        val systemClassLoader = (kotlin.runCatching {&#13;&#10;            lpparam.classLoader.loadClass(&quot;android.app.ActivityThread&quot;)&#13;&#10;                ?: Class.forName(&quot;android.app.ActivityThread&quot;)&#13;&#10;        }.onFailure {&#13;&#10;            Logger.error(&quot;Failed to find ActivityThread&quot;, it)&#13;&#10;        }.getOrNull() ?: return)&#13;&#10;            .getMethod(&quot;currentActivityThread&quot;)&#13;&#10;            .invoke(null)&#13;&#10;            .javaClass&#13;&#10;            .getClassLoader()&#13;&#10;&#13;&#10;        if (systemClassLoader == null) {&#13;&#10;            Logger.error(&quot;Failed to get system class loader&quot;)&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        if(System.getProperty(&quot;portal.injected_${lpparam.packageName}&quot;) == &quot;true&quot;) {&#13;&#10;            return&#13;&#10;        } else {&#13;&#10;            System.setProperty(&quot;portal.injected_${lpparam.packageName}&quot;, &quot;true&quot;)&#13;&#10;        }&#13;&#10;&#13;&#10;        when (lpparam.packageName) {&#13;&#10;            &quot;com.android.phone&quot; -&gt; {&#13;&#10;                Logger.info(&quot;Found com.android.phone&quot;)&#13;&#10;                TelephonyHook(lpparam.classLoader)&#13;&#10;                MiuiTelephonyManagerHook(lpparam.classLoader)&#13;&#10;            }&#13;&#10;            &quot;android&quot; -&gt; {&#13;&#10;                Logger.info(&quot;Debug Log Status: ${FakeLoc.enableDebugLog}&quot;)&#13;&#10;                FakeLoc.isSystemServerProcess = true&#13;&#10;                startFakeLocHook(systemClassLoader)&#13;&#10;                TelephonyHook.hookSubOnTransact(lpparam.classLoader)&#13;&#10;                WlanHook(systemClassLoader)&#13;&#10;                AndroidFusedLocationProviderHook(lpparam.classLoader)&#13;&#10;                SystemSensorManagerHook(lpparam.classLoader)&#13;&#10;&#13;&#10;                ThirdPartyLocationHook(lpparam.classLoader)&#13;&#10;            }&#13;&#10;            &quot;com.android.location.fused&quot; -&gt; {&#13;&#10;                AndroidFusedLocationProviderHook(lpparam.classLoader)&#13;&#10;            }&#13;&#10;            &quot;com.xiaomi.location.fused&quot; -&gt; {&#13;&#10;                ThirdPartyLocationHook(lpparam.classLoader)&#13;&#10;            }&#13;&#10;            &quot;com.oplus.location&quot; -&gt; {&#13;&#10;                OplusLocationHook(lpparam.classLoader)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun startFakeLocHook(classLoader: ClassLoader) {&#13;&#10;        cServiceManager = XposedHelpers.findClass(&quot;android.os.ServiceManager&quot;, classLoader)&#13;&#10;&#13;&#10;        XposedHelpers.findClassIfExists(&quot;com.android.server.TelephonyRegistry&quot;, classLoader)?.let {&#13;&#10;            TelephonyHook.hookTelephonyRegistry(it)&#13;&#10;        } // for MUMU emulator&#13;&#10;&#13;&#10;        val cLocationManager =&#13;&#10;            XposedHelpers.findClass(&quot;android.location.LocationManager&quot;, classLoader)&#13;&#10;&#13;&#10;        LocationServiceHook(classLoader)&#13;&#10;        LocationManagerHook(cLocationManager)  // intrusive hooks&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/xposed/src/main/java/moe/fuqiuluo/xposed/hooks/wlan/WifiHookManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/xposed/src/main/java/moe/fuqiuluo/xposed/hooks/wlan/WifiHookManager.kt" />
              <option name="updatedContent" value="package moe.fuqiuluo.xposed.hooks.wlan&#10;&#10;import moe.fuqiuluo.xposed.utils.Logger&#10;&#10;/**&#10; * WiFi Hook管理器&#10; * 用于管理地图应用WiFi数据拦截的配置和状态&#10; */&#10;object WifiHookManager {&#10;    &#10;    // WiFi Hook是否启用&#10;    var isWifiHookEnabled: Boolean = true&#10;        set(value) {&#10;            field = value&#10;            Logger.info(&quot;WiFi Hook状态已${if (value) &quot;启用&quot; else &quot;禁用&quot;}&quot;)&#10;        }&#10;    &#10;    // 是否启用详细日志&#10;    var isDetailedLogEnabled: Boolean = false&#10;    &#10;    // 白名单应用包名（这些应用不会被Hook）&#10;    private val whitelistPackages = mutableSetOf&lt;String&gt;()&#10;    &#10;    // 黑名单应用包名（强制Hook这些应用）&#10;    private val blacklistPackages = mutableSetOf(&#10;        &quot;com.baidu.BaiduMap&quot;,&#10;        &quot;com.autonavi.minimap&quot;,&#10;        &quot;com.tencent.map&quot;,&#10;        &quot;com.google.android.apps.maps&quot;&#10;    )&#10;    &#10;    /**&#10;     * 添加应用到白名单&#10;     */&#10;    fun addToWhitelist(packageName: String) {&#10;        whitelistPackages.add(packageName)&#10;        Logger.info(&quot;已将 $packageName 添加到WiFi Hook白名单&quot;)&#10;    }&#10;    &#10;    /**&#10;     * 从白名单移除应用&#10;     */&#10;    fun removeFromWhitelist(packageName: String) {&#10;        whitelistPackages.remove(packageName)&#10;        Logger.info(&quot;已将 $packageName 从WiFi Hook白名单移除&quot;)&#10;    }&#10;    &#10;    /**&#10;     * 添加应用到黑名单&#10;     */&#10;    fun addToBlacklist(packageName: String) {&#10;        blacklistPackages.add(packageName)&#10;        Logger.info(&quot;已将 $packageName 添加到WiFi Hook黑名单&quot;)&#10;    }&#10;    &#10;    /**&#10;     * 从黑名单移除应用&#10;     */&#10;    fun removeFromBlacklist(packageName: String) {&#10;        blacklistPackages.remove(packageName)&#10;        Logger.info(&quot;已将 $packageName 从WiFi Hook黑名单移除&quot;)&#10;    }&#10;    &#10;    /**&#10;     * 判断是否应该Hook指定应用&#10;     */&#10;    fun shouldHookPackage(packageName: String): Boolean {&#10;        // 如果WiFi Hook未启用，则不Hook任何应用&#10;        if (!isWifiHookEnabled) {&#10;            return false&#10;        }&#10;        &#10;        // 白名单中的应用不Hook&#10;        if (whitelistPackages.contains(packageName)) {&#10;            return false&#10;        }&#10;        &#10;        // 黑名单中的应用强制Hook&#10;        if (blacklistPackages.contains(packageName)) {&#10;            return true&#10;        }&#10;        &#10;        // 检查包名是否包含地图相关关键词&#10;        val mapKeywords = listOf(&quot;map&quot;, &quot;location&quot;, &quot;gps&quot;, &quot;navigation&quot;, &quot;baidu&quot;, &quot;amap&quot;, &quot;tencent&quot;)&#10;        return mapKeywords.any { packageName.contains(it, ignoreCase = true) }&#10;    }&#10;    &#10;    /**&#10;     * 获取当前白名单&#10;     */&#10;    fun getWhitelist(): Set&lt;String&gt; = whitelistPackages.toSet()&#10;    &#10;    /**&#10;     * 获取当前黑名单&#10;     */&#10;    fun getBlacklist(): Set&lt;String&gt; = blacklistPackages.toSet()&#10;    &#10;    /**&#10;     * 重置所有配置&#10;     */&#10;    fun reset() {&#10;        whitelistPackages.clear()&#10;        blacklistPackages.clear()&#10;        blacklistPackages.addAll(setOf(&#10;            &quot;com.baidu.BaiduMap&quot;,&#10;            &quot;com.autonavi.minimap&quot;, &#10;            &quot;com.tencent.map&quot;,&#10;            &quot;com.google.android.apps.maps&quot;&#10;        ))&#10;        isWifiHookEnabled = true&#10;        isDetailedLogEnabled = false&#10;        Logger.info(&quot;WiFi Hook配置已重置&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>